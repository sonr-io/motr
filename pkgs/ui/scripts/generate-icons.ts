#!/usr/bin/env bun

import { readdirSync, statSync, writeFileSync, mkdirSync, existsSync, rmSync } from 'fs';
import { join, relative, parse, dirname } from 'path';

interface IconMetadata {
  name: string;
  componentName: string;
  library: string; // The icon library (folder name)
  type: 'svg' | 'lottie';
  importPath: string;
}

function toPascalCase(str: string): string {
  return str
    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())
    .replace(/^(.)/, (_, char) => char.toUpperCase())
    .replace(/[^a-zA-Z0-9]/g, '');
}

function findAssetsInLibrary(dir: string, baseDir: string, library: string): IconMetadata[] {
  const assets: IconMetadata[] = [];

  try {
    const entries = readdirSync(dir);

    for (const entry of entries) {
      const fullPath = join(dir, entry);
      const stat = statSync(fullPath);

      if (stat.isDirectory()) {
        // Recursively search subdirectories within the same library
        assets.push(...findAssetsInLibrary(fullPath, baseDir, library));
      } else if (stat.isFile()) {
        const ext = parse(entry).ext.toLowerCase();
        const name = parse(entry).name;

        if (ext === '.svg' || ext === '.json') {
          const type = ext === '.svg' ? 'svg' : 'lottie';
          const componentName = toPascalCase(name);
          const importPath = relative(baseDir, fullPath).replace(/\\/g, '/');

          assets.push({
            name,
            componentName,
            library,
            type,
            importPath,
          });
        }
      }
    }
  } catch (error) {
    console.warn(`Warning: Could not read directory ${dir}:`, error);
  }

  return assets;
}

function findAllLibraries(assetsDir: string, baseDir: string): Map<string, IconMetadata[]> {
  const libraries = new Map<string, IconMetadata[]>();

  try {
    const entries = readdirSync(assetsDir);

    // First, collect root-level icons as "default" library
    const rootIcons: IconMetadata[] = [];
    for (const entry of entries) {
      const fullPath = join(assetsDir, entry);
      const stat = statSync(fullPath);

      if (stat.isFile()) {
        const ext = parse(entry).ext.toLowerCase();
        const name = parse(entry).name;

        if (ext === '.svg' || ext === '.json') {
          const type = ext === '.svg' ? 'svg' : 'lottie';
          const componentName = toPascalCase(name);
          const importPath = relative(baseDir, fullPath).replace(/\\/g, '/');

          rootIcons.push({
            name,
            componentName,
            library: 'default',
            type,
            importPath,
          });
        }
      }
    }

    if (rootIcons.length > 0) {
      libraries.set('default', rootIcons);
    }

    // Then, collect icons from each subdirectory as separate libraries
    for (const entry of entries) {
      const fullPath = join(assetsDir, entry);
      const stat = statSync(fullPath);

      if (stat.isDirectory()) {
        const libraryIcons = findAssetsInLibrary(fullPath, baseDir, entry);
        if (libraryIcons.length > 0) {
          libraries.set(entry, libraryIcons);
        }
      }
    }
  } catch (error) {
    console.warn(`Warning: Could not read assets directory:`, error);
  }

  return libraries;
}

function generateIconComponent(icon: IconMetadata): string {
  if (icon.type === 'svg') {
    return `import { forwardRef } from 'react';
import type { LucideProps } from 'lucide-react';
import { SvgIcon } from '../ui/svg-icon';
import { ReactComponent as ${icon.componentName}Svg } from '../../../${icon.importPath}';

export const ${icon.componentName} = forwardRef<SVGSVGElement, Omit<LucideProps, 'ref'>>((props, ref) => (
  <SvgIcon ref={ref} icon={${icon.componentName}Svg} {...props} />
));

${icon.componentName}.displayName = '${icon.componentName}';
`;
  } else {
    return `import { forwardRef } from 'react';
import type { LucideProps } from 'lucide-react';
import { LottieIcon } from '../ui/lottie-icon';
import animationData from '../../../${icon.importPath}';

export const ${icon.componentName} = forwardRef<SVGSVGElement, Omit<LucideProps, 'ref'>>((props, ref) => (
  <LottieIcon ref={ref as any} animationData={animationData} {...props} />
));

${icon.componentName}.displayName = '${icon.componentName}';
`;
  }
}

function generateLibraryIndexFile(library: string, icons: IconMetadata[]): string {
  const lines: string[] = [
    `// Auto-generated ${library} icon library exports`,
    '// Do not edit this file manually',
    '',
  ];

  for (const icon of icons) {
    lines.push(`export { ${icon.componentName} } from './${icon.componentName}';`);
  }

  return lines.join('\n');
}

function generateIconExports(libraries: Map<string, IconMetadata[]>): string[] {
  const lines: string[] = [];

  if (libraries.size === 0) {
    return ['// No generated icons found'];
  }

  lines.push('// Auto-generated icon library exports');
  lines.push('// Generated from src/assets');
  lines.push('');

  // Export base icon components
  lines.push("export { LottieIcon } from './ui/lottie-icon';");
  lines.push("export type { LottieIconProps } from './ui/lottie-icon';");
  lines.push("export { SvgIcon } from './ui/svg-icon';");
  lines.push("export type { SvgIconProps } from './ui/svg-icon';");
  lines.push("export type { LucideIcon } from './ui/icon-types';");
  lines.push('');

  // Export each library's icons
  for (const [library, icons] of libraries) {
    const libraryExportName = library === 'default' ? 'Default' : toPascalCase(library);
    lines.push(`// ${libraryExportName} icon library`);
    lines.push(`export * as ${libraryExportName}Icons from './icons/${library}';`);
  }

  return lines;
}

async function main() {
  const srcDir = join(import.meta.dir, '../src');
  const assetsDir = join(srcDir, 'assets');
  const componentsDir = join(srcDir, 'components');
  const iconsDir = join(componentsDir, 'icons');

  console.log('🔍 Scanning for icon libraries...');

  // Find all icon libraries
  const libraries = findAllLibraries(assetsDir, srcDir);

  let totalIcons = 0;
  let totalSvg = 0;
  let totalLottie = 0;

  for (const [library, icons] of libraries) {
    totalIcons += icons.length;
    totalSvg += icons.filter(i => i.type === 'svg').length;
    totalLottie += icons.filter(i => i.type === 'lottie').length;
  }

  console.log(`📦 Found ${totalIcons} icons across ${libraries.size} libraries:`);
  console.log(`   - SVG: ${totalSvg}`);
  console.log(`   - Lottie: ${totalLottie}`);
  console.log(`📚 Libraries: ${Array.from(libraries.keys()).join(', ')}`);

  // Clean and recreate icons directory
  if (existsSync(iconsDir)) {
    rmSync(iconsDir, { recursive: true });
  }
  mkdirSync(iconsDir, { recursive: true });

  // Generate icon components for each library
  console.log('✨ Generating icon components...');
  for (const [library, icons] of libraries) {
    const libraryDir = join(iconsDir, library);
    mkdirSync(libraryDir, { recursive: true });

    console.log(`   📁 ${library}: ${icons.length} icons`);

    // Generate individual icon components
    for (const icon of icons) {
      const componentPath = join(libraryDir, `${icon.componentName}.tsx`);
      const componentCode = generateIconComponent(icon);
      writeFileSync(componentPath, componentCode, 'utf-8');
    }

    // Generate library index file
    const libraryIndexPath = join(libraryDir, 'index.ts');
    const libraryIndexCode = generateLibraryIndexFile(library, icons);
    writeFileSync(libraryIndexPath, libraryIndexCode, 'utf-8');
  }

  // Update components/index.ts with icon exports
  console.log('📝 Updating components/index.ts...');
  const componentIndexPath = join(componentsDir, 'index.ts');
  const iconExports = generateIconExports(libraries);

  // Read existing index.ts content and inject icon exports
  let existingContent = '';
  if (existsSync(componentIndexPath)) {
    existingContent = await Bun.file(componentIndexPath).text();
  }

  // Remove old icon exports if they exist
  const iconExportStart = '// Auto-generated icon library exports';
  const iconExportEnd = lines => {
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes('export * as') && lines[i].includes('Icons from')) {
        // Find the end of icon exports
        let j = i;
        while (j < lines.length && (lines[j].includes('export * as') || lines[j].trim() === '' || lines[j].includes('// ') || lines[j].includes('export {'))) {
          j++;
        }
        return j;
      }
    }
    return -1;
  };

  const existingLines = existingContent.split('\n');
  let newLines = [...existingLines];

  // Find and remove old icon exports
  const startIdx = existingLines.findIndex(line => line.includes(iconExportStart));
  if (startIdx !== -1) {
    const endIdx = iconExportEnd(existingLines.slice(startIdx));
    if (endIdx !== -1) {
      newLines.splice(startIdx, endIdx);
    }
  }

  // Add new icon exports at the end
  const finalContent = [...newLines, '', ...iconExports].join('\n');

  await Bun.write(componentIndexPath, finalContent);

  console.log('✅ Icon generation complete!');
  console.log(`   Generated ${totalIcons} icon components in src/components/icons/`);
  console.log(`   Created ${libraries.size} icon libraries`);
  console.log(`   Updated src/components/index.ts with exports`);
}

main().catch(console.error);
