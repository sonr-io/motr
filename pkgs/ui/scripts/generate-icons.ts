#!/usr/bin/env bun

import { readdirSync, statSync, writeFileSync, mkdirSync, existsSync, rmSync } from 'fs';
import { join, relative, parse } from 'path';

interface IconMetadata {
  name: string;
  componentName: string;
  type: 'svg' | 'lottie';
  importPath: string;
  originalPath: string; // Keep track of where it came from (for debugging)
}

function toPascalCase(str: string): string {
  return str
    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())
    .replace(/^(.)/, (_, char) => char.toUpperCase())
    .replace(/[^a-zA-Z0-9]/g, '');
}

function findAllAssets(dir: string, baseDir: string, currentPath: string = ''): IconMetadata[] {
  const assets: IconMetadata[] = [];

  try {
    const entries = readdirSync(dir);

    for (const entry of entries) {
      const fullPath = join(dir, entry);
      const stat = statSync(fullPath);

      if (stat.isDirectory()) {
        // Recursively search subdirectories
        const subPath = currentPath ? `${currentPath}/${entry}` : entry;
        assets.push(...findAllAssets(fullPath, baseDir, subPath));
      } else if (stat.isFile()) {
        const ext = parse(entry).ext.toLowerCase();
        const baseName = parse(entry).name;

        if (ext === '.svg' || ext === '.json') {
          const type = ext === '.svg' ? 'svg' : 'lottie';

          // Create unique component name by combining path and filename
          // e.g., "lucide/arrow-right.svg" -> "LucideArrowRight"
          const nameWithPath = currentPath
            ? `${currentPath.replace(/\//g, '-')}-${baseName}`
            : baseName;

          const componentName = toPascalCase(nameWithPath);
          const importPath = relative(baseDir, fullPath).replace(/\\/g, '/');
          const originalPath = currentPath ? `${currentPath}/${entry}` : entry;

          assets.push({
            name: baseName,
            componentName,
            type,
            importPath,
            originalPath,
          });
        }
      }
    }
  } catch (error) {
    console.warn(`Warning: Could not read directory ${dir}:`, error);
  }

  return assets;
}

function generateIconComponent(icon: IconMetadata): string {
  if (icon.type === 'svg') {
    return `// Auto-generated from ${icon.originalPath}
import { forwardRef } from 'react';
import type { LucideProps } from 'lucide-react';
import { SvgIcon } from '../ui/svg-icon';
import ${icon.componentName}Svg from '../../${icon.importPath}?react';

export const ${icon.componentName} = forwardRef<SVGSVGElement, Omit<LucideProps, 'ref'>>((props, ref) => (
  <SvgIcon ref={ref} icon={${icon.componentName}Svg} {...props} />
));

${icon.componentName}.displayName = '${icon.componentName}';
`;
  } else {
    return `// Auto-generated from ${icon.originalPath}
import { forwardRef } from 'react';
import type { LucideProps } from 'lucide-react';
import { LottieIcon } from '../ui/lottie-icon';
import animationData from '../../${icon.importPath}';

export const ${icon.componentName} = forwardRef<SVGSVGElement, Omit<LucideProps, 'ref'>>((props, ref) => (
  <LottieIcon ref={ref as any} animationData={animationData} {...props} />
));

${icon.componentName}.displayName = '${icon.componentName}';
`;
  }
}

function generateIconsIndexFile(icons: IconMetadata[]): string {
  const lines: string[] = [
    '// Auto-generated icon exports',
    '// Do not edit this file manually',
    '// Generated from src/assets',
    '',
  ];

  // Export base icon components
  lines.push("export { LottieIcon } from '../ui/lottie-icon';");
  lines.push("export type { LottieIconProps } from '../ui/lottie-icon';");
  lines.push("export { SvgIcon } from '../ui/svg-icon';");
  lines.push("export type { SvgIconProps } from '../ui/svg-icon';");
  lines.push("export type { LucideIcon } from '../ui/icon-types';");
  lines.push('');

  // Export all icons
  for (const icon of icons) {
    lines.push(`export { ${icon.componentName} } from './${icon.componentName}';`);
  }

  return lines.join('\n');
}

async function main() {
  const srcDir = join(import.meta.dir, '../src');
  const assetsDir = join(srcDir, 'assets');
  const componentsDir = join(srcDir, 'components');
  const iconsDir = join(componentsDir, 'icons');

  console.log('üîç Scanning for icons in assets directory...');

  // Find all icons recursively
  const icons = findAllAssets(assetsDir, srcDir);

  const totalSvg = icons.filter(i => i.type === 'svg').length;
  const totalLottie = icons.filter(i => i.type === 'lottie').length;

  console.log(`üì¶ Found ${icons.length} icons:`);
  console.log(`   - SVG: ${totalSvg}`);
  console.log(`   - Lottie: ${totalLottie}`);

  if (icons.length === 0) {
    console.log('‚ö†Ô∏è  No icons found in assets directory');
    return;
  }

  // Clean and recreate icons directory (flat structure)
  if (existsSync(iconsDir)) {
    console.log('üßπ Cleaning existing icons directory...');
    rmSync(iconsDir, { recursive: true });
  }
  mkdirSync(iconsDir, { recursive: true });

  // Generate icon components (all in root /icons/ directory)
  console.log('‚ú® Generating icon components...');
  for (const icon of icons) {
    const componentPath = join(iconsDir, `${icon.componentName}.tsx`);
    const componentCode = generateIconComponent(icon);
    writeFileSync(componentPath, componentCode, 'utf-8');
  }

  // Generate icons index file
  console.log('üìù Generating icons/index.ts...');
  const iconsIndexPath = join(iconsDir, 'index.ts');
  const iconsIndexCode = generateIconsIndexFile(icons);
  writeFileSync(iconsIndexPath, iconsIndexCode, 'utf-8');

  console.log('‚úÖ Icon generation complete!');
  console.log(`   Generated ${icons.length} icon components in src/components/icons/`);
  console.log(`   All icons are in a flat directory structure`);
  console.log(`   Import icons from: "@sonr.io/ui/components/icons"`);
}

main().catch(console.error);
